name: Desplegar Microservicios en AWS

on:
  push:
    branches: [ main, release ]
  workflow_dispatch:

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      changed-services: ${{ steps.detect.outputs.changed-services }}
      has-changes: ${{ steps.detect.outputs.has-changes }}
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1

    - name: Detectar servicios modificados
      id: detect
      run: |
        chmod +x aws-deployment/detect-changes.sh
        ./aws-deployment/detect-changes.sh
        
        # Leer servicios modificados del archivo generado
        if [ -f .env.changes ]; then
          CHANGED_SERVICES=$(grep "CHANGED_SERVICES=" .env.changes | cut -d'=' -f2-)
          echo "changed-services=$CHANGED_SERVICES" >> $GITHUB_OUTPUT
          
          if [ -n "$CHANGED_SERVICES" ] && [ "$CHANGED_SERVICES" != "[]" ]; then
            echo "has-changes=true" >> $GITHUB_OUTPUT
            echo "🚀 Servicios a desplegar: $CHANGED_SERVICES"
          else
            echo "has-changes=false" >> $GITHUB_OUTPUT
            echo "✅ No hay servicios que necesiten despliegue"
          fi
        else
          echo "changed-services=[]" >> $GITHUB_OUTPUT
          echo "has-changes=false" >> $GITHUB_OUTPUT
        fi

  deploy-services:
    needs: detect-changes
    if: needs.detect-changes.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.changed-services) }}
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Extraer versión del servicio
      id: version
      run: |
        VERSION=$(grep -o 'version="[^"]*"' ${{ matrix.service }}/main.py | sed 's/version="\(.*\)"/\1/')
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "📦 Versión detectada para ${{ matrix.service }}: $VERSION"

    - name: Create ECR repository if not exists
      run: |
        ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
        SERVICE_NAME=${{ matrix.service }}
        
        echo "🔍 Verificando si el repositorio $SERVICE_NAME existe en ECR"
        
        # Verificar si el repositorio existe
        if aws ecr describe-repositories --repository-names $SERVICE_NAME --region us-east-1 >/dev/null 2>&1; then
          echo "✅ Repositorio $SERVICE_NAME ya existe"
        else
          echo "📦 Creando repositorio $SERVICE_NAME en ECR"
          aws ecr create-repository \
            --repository-name $SERVICE_NAME \
            --region us-east-1 \
            --image-scanning-configuration scanOnPush=true \
            --encryption-configuration encryptionType=AES256
          echo "✅ Repositorio $SERVICE_NAME creado exitosamente"
        fi

    - name: Construir y subir imagen Docker
      run: |
        ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
        SERVICE_VERSION=${{ steps.version.outputs.version }}
        
        echo "🏗️ Construyendo imagen para ${{ matrix.service }} versión $SERVICE_VERSION"
        
        # Construir imagen con versión específica
        docker build -t $ECR_REGISTRY/${{ matrix.service }}:$SERVICE_VERSION ./${{ matrix.service }}/
        docker build -t $ECR_REGISTRY/${{ matrix.service }}:latest ./${{ matrix.service }}/
        
        # Subir ambas versiones
        docker push $ECR_REGISTRY/${{ matrix.service }}:$SERVICE_VERSION
        docker push $ECR_REGISTRY/${{ matrix.service }}:latest
        
        echo "✅ Imagen desplegada: $ECR_REGISTRY/${{ matrix.service }}:$SERVICE_VERSION"

    - name: Desplegar en ECS
      run: |
        ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
        SERVICE_VERSION=${{ steps.version.outputs.version }}
        
        # Configurar variables de entorno
        export ECR_REGISTRY
        export POSTGRES_DB=postgres
        export POSTGRES_USER=postgres
        export POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
        export POSTGRES_HOST=${{ secrets.RDS_ENDPOINT }}
        export POSTGRES_PORT=5432
        export NIT_DATABASE_URL=postgresql+psycopg://nit_service:nit_password@${{ secrets.RDS_ENDPOINT }}:5432/nit_db
        export USER_DATABASE_URL=postgresql+psycopg://user_service:user_password@${{ secrets.RDS_ENDPOINT }}:5432/user_db
        export AUDIT_DATABASE_URL=postgresql+psycopg://audit_service:audit_password@${{ secrets.RDS_ENDPOINT }}:5432/audit_db
        export REDIS_URL=redis://${{ secrets.REDIS_ENDPOINT }}:6379
        export REDIS_TTL=3600
        export JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY }}
        export JWT_EXPIRE_MINUTES=60
        
        # Instalar ecs-cli
        sudo curl -o /usr/local/bin/ecs-cli https://amazon-ecs-cli.s3.amazonaws.com/ecs-cli-linux-amd64-latest
        sudo chmod +x /usr/local/bin/ecs-cli
        
        # Configurar ECS CLI
        ecs-cli configure --cluster microservices-cluster --region us-east-1 --default-launch-type FARGATE
        
        # Crear un docker-compose temporal solo para el servicio modificado
        echo "📦 Creando docker-compose temporal para ${{ matrix.service }}"
        cat > docker-compose.temp.yml << EOF
version: '3.8'
services:
  ${{ matrix.service }}:
    image: $ECR_REGISTRY/${{ matrix.service }}:$SERVICE_VERSION
    environment:
      - POSTGRES_DB=\${POSTGRES_DB}
      - POSTGRES_USER=\${POSTGRES_USER}
      - POSTGRES_PASSWORD=\${POSTGRES_PASSWORD}
      - POSTGRES_HOST=\${POSTGRES_HOST}
      - POSTGRES_PORT=\${POSTGRES_PORT}
      - NIT_DATABASE_URL=\${NIT_DATABASE_URL}
      - USER_DATABASE_URL=\${USER_DATABASE_URL}
      - AUDIT_DATABASE_URL=\${AUDIT_DATABASE_URL}
      - REDIS_URL=\${REDIS_URL}
      - REDIS_TTL=\${REDIS_TTL}
      - JWT_SECRET_KEY=\${JWT_SECRET_KEY}
      - JWT_EXPIRE_MINUTES=\${JWT_EXPIRE_MINUTES}
    ports:
      - "8000:8000"
    logging:
      driver: awslogs
      options:
        awslogs-group: /ecs/${{ matrix.service }}
        awslogs-region: us-east-1
        awslogs-stream-prefix: ecs
EOF
        
        # Desplegar el servicio usando el archivo temporal
        ecs-cli compose -f docker-compose.temp.yml up --create-log-groups --force-update

    - name: Verificar despliegue
      run: |
        echo "🔍 Verificando despliegue de ${{ matrix.service }}..."
        
        # Esperar un momento para que el servicio se estabilice
        sleep 30
        
        # Verificar que el servicio esté ejecutándose
        aws ecs describe-services \
          --cluster microservices-cluster \
          --services ${{ matrix.service }} \
          --query 'services[0].status' \
          --output text
        
        echo "✅ Despliegue de ${{ matrix.service }} completado"

  notify-completion:
    needs: [detect-changes, deploy-services]
    runs-on: ubuntu-latest
    if: always()
    steps:
    - name: Notificar resultado
      run: |
        if [ "${{ needs.detect-changes.outputs.has-changes }}" = "true" ]; then
          echo "🎉 Despliegue completado para: ${{ needs.detect-changes.outputs.changed-services }}"
        else
          echo "✅ No se requirió despliegue - todos los servicios están actualizados"
        fi
